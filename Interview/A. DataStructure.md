## 자료구조

- 스택 2개로 큐 만들기
```
Queue는 선입선출(FIFO) 구조이고 Stack은 후입선출(LIFO) 구조이다.
Stack은 Reverse구조이기 때문에 1 > 2 > 3으로 들어간 값이 나올땐 3 > 2 > 1이 된다.
하지만 두개의 스택을 이용하면 Reverser를 두번 하기 때문에 원래 상태로 돌아간다.
Stack1 [1, 2, 3]에 들어간 원소를 Stack2에 담으면 [3, 2, 1]이 되고 이를 다시 순서대로 꺼내면 1 > 2 > 3이 된다.
push, pop을 순서대로 하면 input stack, output stack을 구분해서 데이터만 옮겨주면 되지만 push, pop이 섞이게 될 경우 어려워지게 된다.
아래 예시를 보자. []에서 오른쪽이 스택의 입구이다
---------------------------------------------------------------
push 1, push 2, pop, push 3, push 4, pop, push 5, pop, pop, pop
---------------------------------------------------------------
Queue를 이용하면 순서는 아래처럼 된다.
1. push 1, push 2 = [1, 2]
2. pop = 1, [2]
3. push 3, push 4 = [2, 3, 4]
4. pop = 2, [3, 4]
5. push 5 = [3, 4, 5]
6. pop, pop, pop = 3, 4, 5, []

2개의 스택을 이용하면 아래처럼 해야한다.
1. push 1, push 2
is = [1, 2]
os = []
2. pop
pop 연산을 하게 될 경우 os이 비어있으면 is의 데이터를 os으로 전부 옮겨야 한다.
is = []
os = [2, 1]
os = [2], 1(pop)
3. push 3, push 4
is = [3, 4]
os = [2]
4. pop
os의 데이터가 남아있으니 os의 데이터를 pop한다
is = [3, 4]
os = [], 2(pop)
5. push 5
is = [3, 4, 5]
os = []
6. pop, pop, pop
os가 비어있으니 is의 데이터를 전부 os로 옮긴다.
is = []
os = [5, 4, 3]
os = [], 3, 4, 5(pop pop pop)
```
- 큐 2개로 스택 만들기
```
Queue는 선입선출(FIFO) 구조이고 Stack은 후입선출(LIFO) 구조이다.
---------------------------------------------------------------
push 1, push 2, pop, push 3, push 4, pop, push 5, pop, pop, pop
---------------------------------------------------------------
Stack을 이용하면 순서는 아래처럼 된다. [] < 오른쪽이 스택의 입구이다.
1. push 1, push 2 = [1, 2]
2. pop = [1], 2
3. push 3, push 4 = [1, 3, 4]
4. pop = [1, 3], 4
5. push 5 = [1, 3, 5]
6. pop, pop, pop = [], 5, 3, 1
pop된 순서대로 적어보면  2, 4, 5, 3, 1 순서이다
큐 2개를 q1, q2로 구성한다. queue는 < [] < 오른쪽으로 들어가서 왼쪽으로 나간다.
1. push 1, push 2
q1 = [1, 2]
q2 = []
2. pop
q2가 비어있으니 q1에서 q2로 데이터를 전부 옮기고, 마지막 하나 남은 데이터가 있을 시 출력 후 pop한다.
q2의 데이터를 다시 q1으로 옮긴다.
q1 = [2]
q2 = [1]
q1.pop(), 2, []
q1 = [1]
q2 = []
3. push 3, push 4
q1가 비어있으니 q1에 전부 삽입
q1 = [1, 3, 4]
q2 = []
4. pop
q1에서 q2로 원소가 하나 남을 때 까지 이동시키고 출력 후 pop한다.
q1 = [4]
q2 = [1, 3]
q1.pop() 4, []
다시 q2의 모든 원소를 q1로 이동한다.
q1 = [1, 3]
q2 = []
5. push 5
q1 = [1, 3, 5]
q2 = []
6. pop, pop, pop
위 작업을 그대로 반복한다. q1에 데이터가 하나 남을때까지 q2로 옮기고 출력 후 pop
q1 = [5]
q2 = [1, 3]
q1.pop() 5, [] pop 후 q2의 모든 원소 q1로 이동

q1 = [1, 3]
q2 = []

q1 = [3]
q2 = [1]
q1.pop() 3, [] pop 후 q2의 모든 원소 q1로 이동

q1 = [1]
q2 = []
q1.pop() 1, []

최종 출력 : 2, 4, 5, 3, 1
```
- Prefix, Infix, Postfix 에 대해 설명하고, 이를 스택을 활용해서 계산하는 방법에 대해 설명해 주세요.
```
전위 표기식, 중위 표기식, 후위 표기식에 관한 문제이다.
BOJ에도 비슷한 문제가 있다.(https://www.acmicpc.net/problem/1935, https://www.acmicpc.net/problem/1918)
전위 표기식은 연산자가 피연산자 앞에 오는 표기법이다(+AB)
중위 표기식은 일반적으로 쓰는 표기방법이다(A+B)
후위 표기식은 연산자가 피연산자의 뒤에 오는 표기방법이다.(AB+)

중위 표기식을 후위 표기식으로 바꾸어 계산한다.
들어가기 전 연산자 우선순위를 고려해야 한다.
1순위 : ( )
2순위 : * /
3순위 : + -

(4-(1+3)*2)+(4/2)
1. 숫자가 나오면 그대로 출력한다.
2. 1순위인 여는 괄호가 나오면 스택에 넣는다.
3. 2순위인 *, /가 나오면 스택에 넣는다.
4. 3순위인 +, - 연산이 나오면 여는 괄호, 여는 괄호가 으면 스택의 끝까지 출력하고 해당 연산자를 스택에 넣는다.
5. 닫는 괄호가 나오면 스택에서 여는 괄호가 나올때까지 pop한다.

결과 : 413+2*-42/+


예제 : (4-(1+3)*2)+(4/2)
계산결과 : -2
예제를 가지고 전위 표기식, 후위 표기식을 만들어준다

---------------------------- 계산법 ----------------------------
전위 표기법 : +-4*+132/42
전위 표기법은 스택의 peek와 현재 값이 숫자이면
스택의 값을 꺼낸 후 스택의 peek가 연산자이면 연산자에 따라 두 값을 계산 후에 다시 스택이 넣어준다.
두 수가 연속적으로 나오기 전 까지 연산자와 숫자를 스택에 계속 삽입한다. 스택의 방향은 [] < 오른쪽이 입구이다.
1. [ +, -, 4, *, + , 1 ]

+-4*+132/42
      ^ 현재 값
2. 스택의 peek가 1이고 현재 값이 3이니 스택의 1을 꺼내 임시값에 저장한다. [ +, -, 4, *, + ]
current = 3, temp = 1
스택의 peek가 +연산이니 두 값을 더하고 연산자를 pop시킨 후 더한 값인 4를 다시 스택에 넣는다.
[ +, -, 4, *, 4 ]

+-4*+132/42
       ^ 현재 값
3. 스택의 peek가 4이고 현재 값이 2이니 스택의 4를 꺼내 임시값에 저장한다. [ +, -, 4, * ]
current = 2, temp = 4
스택의 peek가 * 연산이니 두 값을 곱하고 연산자를 pop 후 곱한 값인 8을 스택에 넣는다
[ +, -, 4, 8]

+-4*+132/42
        ^ 현재 값
4. 현재 값이 연산자니 스택에 넣는다
[ +, -, 4, 8, / ]

+-4*+132/42
         ^ 현재값
5. 스택의 peek가 연산자고 현재 값이 숫자니 스택에 넣는다
[ +, -, 4, 8, /, 4 ]

+-4*+132/42
          ^ 현재 값
6. 스택의 peek가 4이고 현재값이 2이니 스택의 4를 꺼내 임시값에 저장한다. [ +, -, 4, 8, / ]
current = 2, temp = 4
스택의 peek가 / 연산이니 두 값을 나누고 연산자를 pop한 후 나눈 값인 2를 스택에 넣는다.
[ +, -, 4, 8, 2]

7. 계산식의 순회가 끝났으니 스택의 남은 값을 가지고 계산을 마저 한다.
  7.1 임시 스택 하나를 만든다. []
  7.2 기존 스택에서 연산자가 나올때 까지 값을 임시 스택으로 옮긴다.
      [ +, - ], [ 4, 8, 2 ]
  7.3 기존 스택에서 연산자가 발견되면 임시 스택에 있는 숫자를 두 개 빼고 연산자에 맞춰 계산을 한다. 계산 후 연산자는 pop하고 계산된 값은 임시 스택에 다시 넣는다. 계산은 꺼낸 값 순서대로 계산한다.
      2 - 8 = -6, -> [ + ], [ 4, -6 ]
  7.4 스택이 빌 때 까지 7.2, 7.3을 반복한다.
      4 + (-6) = -2, [], []

결과 : -2

후위 표기법 : 413+2*-42/+
전위 표기법과 비슷하다. 전위 표기법은 현재 값과 스택의 끝이 숫자인지 비교했다면, 후위 표기법은 현재 값이 연산자인지 아닌지 판단한다.
1. 연산자가 오기 전까지 스택에 값을 넣는다.
[ 4, 1, 3 ]

413+2*-42/+
   ^ 현재 값
2. 연산자가 나오면 스택의 값 두개를 빼 연산 후 다시 넣어준다.
   LIFO니 먼저 들어간 1이 앞에 오고 나중에 들어간 3이 뒤에 와야 한다.
   1 + 3 = 4
[ 4, 4 ]

413+2*-42/+
    ^ 현재 값
3. 현재 값이 2이니 스택에 넣는다.
[ 4, 4, 2 ]

413+2*-42/+
     ^ 현재 값
4. 현재 값이 연산자니 스택의 두 값을 빼서 연산 후 스택에 다시 넣어준다. 4 + 2 = 8
[ 4, 8 ]

413+2*-42/+
      ^ 현재 값
5. 현재 값이 연산자니 스택의 두 값을 빼서 연산 후 스택에 다시 넣어준다. 4 - 8 = -4
[ -4 ]

413+2*-42/+
       ^ 현재 값
6. 뒤에 오는 숫자는 계속 스택에 넣어준다.
[ -4, 4, 2 ]

413+2*-42/+
         ^ 현재 값
7. 현재 값이 연산자니 스택의 두 값을 빼서 연산 후 스택에 다시 넣어준다. 4 / 2 = 2
[ -4, 2]

413+2*-42/+
          ^ 현재 값
8. 현재 값이 연산자니 스택의 두 값을 빼서 연산 후 스택에 다시 넣어준다. -4 + 2 = -2
[ -2 ]

9. 다음에 올 값이 없고, 스택의 크기가 1이니 계산이 끝났다.
답 : -2
```
- (C++ 한정) Deque의 Random Access 시간복잡도는 O(1) 입니다. 이게 어떻게 가능한걸까요?
```

```
- 해시 자료구조에 대해 설명해 주세요.
- 값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?
- 해시값이 충돌했을 때, 어떤 방식으로 처리할 수 있을까요?
- 본인이 사용하는 언어에서는, 어떤 방식으로 해시 충돌을 처리하나요?
- Double Hashing 의 장점과 단점에 대해서 설명하고, 단점을 어떻게 해결할 수 있을지 설명해 주세요.
- Load Factor에 대해 설명해 주세요. 본인이 사용하는 언어에서의 해시 자료구조는 Load Factor에 관련한 정책이 어떻게 구성되어 있나요?
- 다른 자료구조와 비교하여, 해시 테이블은 멀티스레드 환경에서 심각한 수준의 Race Condition 문제에 빠질 위험이 있습니다. 성능 감소를 최소화 한 채로 해당 문제를 해결할 수 있는 방법을 설계해 보세요.
- 트리와 이진트리, 이진탐색트리에 대해 설명해 주세요.
- 이진탐색트리에서 중위 탐색을 하게 되면, 그 결과는 어떤 의미를 가지나요?
- 이진탐색트리의 주요 연산에 대한 시간복잡도를 설명하고, 왜 그런 시간복잡도가 도출되는지 설명해 주세요.
- 이진탐색트리의 한계점에 대해 설명해주세요.
- 이진탐색트리의 값 삽입, 삭제 방법에 대해 설명하고, 어떤식으로 값을 삽입하면 편향이 발생할까요?
- 이진탐색트리와 동일한 로직을 사용하면, 삼진탐색트리도 정의할 수 있을까요? 안 된다면, 그 이유에 대해 설명해 주세요.
- 힙에 대해 설명해 주세요.
- 힙을 배열로 구현한다고 가정하면, 어떻게 값을 저장할 수 있을까요?
- 힙의 삽입, 삭제 방식에 대해 설명하고, 왜 이진탐색트리와 달리 편향이 발생하지 않는지 설명해 주세요.
- 힙 정렬의 시간복잡도는 어떻게 되나요? Stable 한가요?
- BBST (Balanced Binary Search Tree) 와, 그 종류에 대해 설명해 주세요.
- Red Black Tree는 어떻게 균형을 유지할 수 있을까요?
- Red Black Tree의 주요 성질 4가지에 대해 설명해 주세요.
- 2-3-4 Tree, AVL Tree 등의 다른 BBST 가 있음에도, 왜 Red Black Tree가 많이 사용될까요?

### 정렬 알고리즘

- 정렬 알고리즘에 대해 설명해 주세요.
- Quick Sort와 Merge Sort를 비교해 주세요.
- Quick Sort에서 O(N^2)이 걸리는 예시를 들고, 이를 개선할 수 있는 방법에 대해 설명해 주세요.
- Stable Sort가 무엇이고, 어떤 정렬 알고리즘이 Stable 한지 설명해 주세요.
- Merge Sort를 재귀를 사용하지 않고 구현할 수 있을까요?
- Radix Sort에 대해 설명해 주세요.
- Bubble, Selection, Insertion Sort의 속도를 비교해 주세요.
- 값이 거의 정렬되어 있거나, 아예 정렬되어 있다면, 위 세 알고리즘의 성능 비교 결과는 달라질까요?
- 본인이 사용하고 있는 언어에선, 어떤 정렬 알고리즘을 사용하여 정렬 함수를 제공하고 있을까요?
- 정렬해야 하는 데이터는 50G 인데, 메모리가 4G라면, 어떤 방식으로 정렬을 진행할 수 있을까요?

### 그래프

- 그래프 자료구조에 대해 설명하고, 이를 구현할 수 있는 두 방법에 대해 설명해 주세요.
- 각 방법에 대해, "두 정점이 연결되었는지" 확인하는 시간복잡도와 "한 정점에 연결된 모든 정점을 찾는" 시간복잡도, 그리고 공간복잡도를 비교해 주세요.
- 정점의 개수가 N개, 간선의 개수가 N^3 개라면, 어떤 방식으로 구현하는 것이 효율적일까요?
- 사이클이 없는 그래프는 모두 트리인가요? 그렇지 않다면, 예시를 들어주세요.
- 그래프에서, 최단거리를 구하는 방법에 대해 설명해 주세요.
- 트리에서는 어떤 방식으로 최단거리를 구할 수 있을까요? (위 방법을 사용하지 않고)
- 다익스트라 알고리즘에서, 힙을 사용하지 않고 구현한다면 시간복잡도가 어떻게 변화할까요?
- 정점의 개수가 N개, 간선의 개수가 N^3 개라면, 어떤 알고리즘이 효율적일까요?
- A\* 알고리즘에 대해 설명해 주세요. 이 알고리즘은 다익스트라와 비교해서 어떤 성능을 낼까요?
- 음수 간선이 있을 때와, 음수 사이클이 있을 때 각각 어떤 최단거리 알고리즘을 사용해야 하는지 설명해 주세요.

### 재귀

- 재귀함수에 대해 설명해 주세요.
- 재귀 함수의 동작 과정을 Call Stack을 활용해서 설명해 주세요.
- 언어의 스펙에 따라, 재귀함수의 최적화를 진행해주는 경우가 있습니다. 어떤 경우에 재귀함수의 최적화가 가능하며, 이를 어떻게 최적화 할 수 있을지 설명해 주세요.

### MST

- MST가 무엇이고, 어떻게 구할 수 있을지 설명해 주세요.
- Kruskal 알고리즘에서 사용하는 Union-Find 자료구조에 대해 설명해 주세요.
- Kruskal 과 Prim 중, 어떤 것이 더 빠를까요?
- Kruskal 과 Prim 알고리즘을 통해 얻어진 결과물은 무조건 트리인가요? 만약 그렇다면 증명해 주세요. 그렇지 않다면, 반례를 설명해 주세요.

### Thread Safe

- Thread Safe 한 자료구조가 있을까요? 없다면, 어떻게 Thread Safe 하게 구성할 수 있을까요?
- 배열의 길이를 알고 있다면, 조금 더 빠른 Thread Safe 한 연산을 만들 순 없을까요?
- 사용하고 있는 언어의 자료구조는 Thread Safe 한가요? 그렇지 않다면, Thread Safe 한 Wrapped Data Structure 를 제공하고 있나요?
- 문자열을 저장하고, 처리하는 주요 자료구조 및 알고리즘 (Trie, KMP, Rabin Karp 등) 에 대해 설명해 주세요.
- 이진탐색이 무엇인지 설명하고, 시간복잡도를 증명해 보세요.
- Lower Bound, Upper Bound 는 무엇이고, 이를 어떻게 구현할 수 있을까요?
- 이진탐색의 논리를 적용하여 삼진탐색을 작성한다고 가정한다면, 시간복잡도는 어떻게 변화할까요? (실제 존재하는 삼진탐색 알고리즘은 무시하세요!)
- 기존 이진탐색 로직에서 부등호의 범위가 바뀐다면,
- 그리디 알고리즘과 동적 계획법을 비교해 주세요.
- 그렇다면, 어떤 경우에 각각의 기법을 사용할 수 있을까요?
  그렇다면, 동적 계획법으로 풀 수 있는 모든 문제는 재귀로 변환하여 풀 수 있나요?
